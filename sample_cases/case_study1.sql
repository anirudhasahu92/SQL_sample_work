/*IntelliPaat
SQL Certification Training
Problem Statement:
You are a database administrator. You want to use the data to answer a few
questions about your customers, especially about the sales and profit coming
from different states, money spent in marketing and various other factors such as
COGS, budget profit etc. You plan on using these insights to help find out which
items are being sold the most. Additionally you need help to generate some basic
datasets so your team can easily inspect the data without needing to use SQL.
You have been provided with the sample of the overall customer data due to
privacy issues. But you hope that these samples are enough for you to write fully
functioning SQL queries to help answer the questions.
Dataset:
The 3 key datasets for this case study:
a. FactTable: The FactTable has 13 columns mentioned below and 4200
rows. Profit, Margin, Sales, COGS, Total Expenses, Marketing, Inventory,
Budget, Profit, Budget COGS, Budget Margin, Budget Sales, Area Code,
and ProductID
Note: COGS stands for Cost of Goods Sold
b. ProductTable: The ProductTable has four columns named Product Type,
Product, ProductID, and Type. It has 13 rows which can be broken down
into further details to retrieve the information mentioned in the FactTable.
c. LocationTable: Finally, the LocationTable has 156 rows and follows a
similar approach to ProductTable. It has four columns named Area Code,
State, Market, and Market Size.*/
--1. Display the number of states present in the LocationTable.
--2. How many products are of regular type?
--3. How much spending has been done on marketing of product ID 1?
--4. What is the minimum sales of a product?
--5. Display the max Cost of Good Sold (COGS).
--6. Display the details of the product ID where product type is coffee.
--7. Display the details where total expenses are greater than 40.
--8. What is the average sales in area code 719?
--9. Find out the total profit generated by Colorado state.
--10. Display the average inventory for each product ID.
--11. Display state in a sequential order in a LocationTable.
--12. Display the average budget margin where the average budget margin
--should be greater than 100.
--13. What is the total sales done on date 2010-01-01?
--14. Display the average total expense of each product ID on an individual
--date.
--15. Display the table with the following attributes such as
--date, product ID, product_type, product, sales, profit, state, area_code.
--16. Display the rank without any gap to show the sales wise rank.
--17. Find the state wise profit and sales.
--18. Find the state wise profit and sales along with the product name.
--19. If there is an increase in sales of 5%, calculate the increased sales.
--20. Find the maximum profit along with the product ID and product type.
--21. Create a stored procedure to fetch the result according to the product
--type from ProductTable.
--22. Write a query by creating a condition in which if the total expenses is
--less than 60 then it is a profit or else loss.
--23. Give the total weekly sales value with the date and product ID details.
--Use roll-up to pull the data in hierarchical order.
--24. Apply union and intersection operator on the tables which consist of
--attribute area code.
--25. Create a user-defined function for the product table to fetch a particular
--product type based upon the user’s preference.
--26. Change the product type from coffee to tea where product ID is 1 and
--undo it.
--27. Display the date, product ID and sales where total expenses are
--between 100 to 200.
--28. Delete the records in the ProductTable for regular type.
--29. Display the ASCII value of the fifth character from the column Product.

create database case_study1;
--the tables have been inserted--casestudy1>right click>task>Import flat file>proceed as per instructions>if you get error>allow null>check tables
select*from fact;
select*from Location;
select*from Product;
--1. Display the number of states present in the LocationTable.
select count(distinct state) as 'Number_of_states' from Location;
--2. How many products are of regular type?
select count(Product_Type) as 'Regular_products' from Product where Type='Regular';
--3. How much spending has been done on marketing of product ID 1?
select sum(Marketing) as 'Total_marketing_expense' from fact where ProductId=1;
--4. What is the minimum sales of a product?
select min(Sales) as 'Min_sales' from fact;
---------------------------
select top(1) sales from fact order by sales asc;
--5. Display the max Cost of Good Sold (COGS).
select top(1) COGS as 'max_COGS' from fact order by COGS desc;
------------------------------------------------------
select max(COGS) as 'max_COGS' from fact;
--6. Display the details of the product ID where product type is coffee.
select*from product where Product_Type like 'coffee';
--7. Display the details where total expenses are greater than 40.
select*from fact where Total_Expenses>40 order by Total_Expenses;
--8. What is the average sales in area code 719?
select avg(sales) as 'Avg_sales' from fact where Area_Code=719;
--9. Find out the total profit generated by Colorado state.
select sum(profit) as 'Profit_Colorado_state' 
from fact f inner join location l on f.Area_Code=l.Area_Code where state='Colorado';
-------------To display state name as well use the query below---
select*from Location;
select*from fact;
SELECT s.state as 'State', t.profit
from location s cross apply  (select sum(profit) as 'profit' 
from fact f inner join location s on f.Area_Code=s.Area_Code where state='Colorado'
 ) t 
group by t.profit,State having state='Colorado';
--10. Display the average inventory for each product ID.
select productid, avg(inventory) as average_inventory from fact group by ProductId order by ProductId asc;
/*
This query calculates the average inventory for each unique `ProductId` in the `fact` table. 
The `GROUP BY` clause groups the data by `ProductId`, and then the `AVG` function calculates 
the average inventory for each group. The `ORDER BY` clause sorts the result in ascending order
based on `ProductId`.
*/
SELECT DISTINCT Productid, 
       AVG(Inventory) OVER(PARTITION BY Productid) AS 'avg_inventory' 
FROM fact Group by productid,Inventory order by ProductId;
/* In this query, the `DISTINCT` keyword is used to remove duplicate rows from the result set. 
The `GROUP BY` clause includes both `ProductId` and `Inventory`, so the result will contain unique 
combinations of `ProductId` and `Inventory`. The `AVG` function with the `OVER(PARTITION BY Productid)` 
calculates the average inventory for each `ProductId` independently, regardless of the `Inventory` values. 
Finally, the `ORDER BY` clause sorts the result set only by `ProductId`.

The difference in results arises because the second query considers the `Inventory` values while grouping, 
which can result in multiple rows for each `ProductId` if there are different `Inventory` values associated 
with it. On the other hand, the first query only groups by `ProductId` and calculates the average inventory 
based on that grouping, without considering the specific `Inventory` values. Therefore, the first query will 
provide one row per unique `ProductId` with the average inventory, while the second query can provide multiple 
rows per `ProductId` depending on the distinct `Inventory` values.
*/
---Now lets not group by both productid and inventory to solve this problem
SELECT DISTINCT Productid, 
       AVG(Inventory) OVER(PARTITION BY Productid) AS 'avg_inventory' 
FROM fact /*Group by productid,Inventory*/ order by ProductId;
--11. Display state in a sequential order in a Location Table.
select distinct state from Location order by state; 
--12. Display the average budget margin where the average budget margin should be greater than 100.
select productid, avg(Budget_Margin) as 'avg_budget_margin' 
from fact group by productid having avg(Budget_Margin)>100 order by productid asc;
--13. What is the total sales done on date 2010-01-01?
select sum(sales) as 'Total_sales' from fact where date='2010-01-01';
--14. Display the average total expense of each product ID on an individual date.
select*from fact 
select avg(Total_expenses) as 'avg_total_exp',productid,date from fact group by productid,date order by productid;
--15. Display the table with the following attributes such as date, product ID, product_type, product, sales, profit, state, area_code.
select*from fact;
select*from Location;
select*from Product;
select f.Date, f.ProductId, p.Product_Type, p.Product, f.Sales, f.Profit, l.State, f.Area_Code from fact f, location l, product p;
--------------Although it returns the result the query does not stop executing and you need to stop it manually---lets complete the query--
select f.Date, f.ProductId, p.Product_Type, p.Product, f.Sales, f.Profit, l.State, f.Area_Code from fact f, location l, product p
where f.Area_Code=l.Area_Code and f.ProductId=p.ProductId;
----The above problem is solved---
--16. Display the rank without any gap to show the sales wise rank
select productid,sales,DENSE_RANK() over(order by sales desc) as sales_rank from fact;
--17. Find the state wise profit and sales.
select * from fact;
select*from location;
select l.state, sum(f.Profit) as profit,sum(f.sales) as sales from location l, fact f where f.Area_Code=l.Area_Code group by l.State;
----------------------
select l.state, sum(f.Profit) as profit,sum(f.sales) as sales from location l, fact f /*where f.Area_Code=l.Area_Code*/ group by l.State;
----------------------
select state, sum(profit)as Profit_State, sum(sales)as Sales_State
 from fact f
 inner join Location L
 on L.Area_Code=f.Area_Code
 group by state; 
--18. Find the state wise profit and sales along with the product name.
select l.State,p.Product,sum(f.Sales) as Sales,sum(f.Profit) 
as Profit from fact f,Location l,Product p group by l.State,p.Product;
--this thing can also done using inner join but this seems more easier (above)
--19. If there is an increase in sales of 5%, calculate the increased sales.
select*from Location;
select*from product;
select*from fact;
select distinct Date,ProductId,(Sales*1.05) as 'Increased_salesby5%' 
from fact order by (Sales*1.05) desc;
--20. Find the maximum profit along with the product ID and product type.
select f.ProductId, p.Product_Type, profit
from fact f inner join product p on f.productid = p.productid where profit = (select max(profit) from fact);
--21. Create a stored procedure to fetch the result according to the product type from ProductTable.
create procedure findproduct (@product_type varchar(30))
as
select * from product where Product_Type=@product_type

CREATE PROCEDURE FetchProductsByType
    @productType VARCHAR(30)
AS
BEGIN
    IF EXISTS (SELECT * FROM Product WHERE Product_Type = @productType)
    BEGIN
        SELECT * FROM Product WHERE Product_Type = @productType;
    END
    ELSE
    BEGIN
        PRINT 'no product found';
    END
END;

--22. Write a query by creating a condition in which if the total expenses is less than 60 then it is a profit or else loss.
SELECT*,
CASE
	WHEN TOTAL_EXPENSES < 60 THEN 'Profit'
	ELSE 'Loss'
END AS [P&L_Statement]
FROM FACT;
--23. Give the total weekly sales value with the date and product ID details. Use roll-up to pull the data in hierarchical order.
select*from Location;
select*from product;
select*from fact;
select datepart(week,date) as week,productId, sum(Sales) as [Product_total_Sales] 
from fact group by rollup (datepart(week,date),ProductId) order by week;
--24. Apply union and intersection operator on the tables which consist of attribute area code.
--Applying union :
select * from fact where Area_Code in (select Area_Code from fact union select Area_Code from Location);
--Lets check the number of records:
select count(*) from (select * from fact where Area_Code in (select Area_Code from fact union select Area_Code from Location))q;
--Applying intersection :
select * from fact where Area_Code in (select Area_Code from fact intersect select Area_Code from Location);
--Lets check the number of records:
select count(*) from (select * from fact where Area_Code in (select Area_Code from fact intersect select Area_Code from Location))q;
--Since the number of records in both the queries are same lets check whether there any unique Area_Code present in one table and not in the
--other:
select Area_code from Location where Area_Code not in (select Area_Code from fact);
select Area_code from fact where Area_Code not in (select Area_Code from Location);
--The answer is no. So, we get the same output for both UNION and INTERSECT operator.
--25. Create a user-defined function for the product table to fetch a particular product type based upon the user’s preference.
select*from Product;
--Lets create the function where if we give Product_Type and Type from the Product table maintained by the store we can get the Product:
create function find_product (@Product_Type varchar(20) , @Type varchar(15))
RETURNS @foundproduct TABLE
(Product varchar(30))
AS
BEGIN
    IF EXISTS (SELECT Product FROM Product WHERE Product_Type = @Product_Type and Type = @Type) --checking the presence of the product
    BEGIN
		INSERT INTO @foundproduct (Product)												--Inserting values into the temp table of the function
        SELECT Product FROM Product WHERE Product_Type = @Product_Type and Type = @Type;
    END
    ELSE
    BEGIN
        INSERT INTO @foundproduct (Product)
        VALUES ('Not Found');   --Since this is a table valued function only a table can be returned so printing or raising error won't work
    END							--since they give a string as output. The alternative strategy is as follows.
	RETURN --Return statement is compulsory in a function at the end.
END;
--Lets check it out :
select*from Product
--Calling the function:
select * from find_product ('Herbal Tea', 'Decaf') --working
select * from find_product ('Coffee', 'Decaf') --working
--Checking the error handing if the product is not found:
select * from find_product ('Tea', 'Decaf') --working

--26. Change the product type from coffee to tea where product ID is 1 and undo it.
BEGIN TRANSACTION
UPDATE Product SET Product_Type = 'Tea' where ProductId = 1;
ROLLBACK TRANSACTION
--Checking the reversal :
select * from Product;  --The Rollback worked 
--27. Display the date, product ID and sales where total expenses are between 100 to 200.
select productid, date, sales, Total_Expenses from fact where Total_Expenses between 100 and 200 order by ProductId;
--28. Delete the records in the Product Table for regular type.
select*from Product;
--Lets create a copy of the Product table as Product1 and use it for this question :
create table Product1 (ProductId int, Product_Type varchar(15), Product varchar(30), Type varchar (10));
select * from Product1;
insert into Product1 select * from Product;
--Solving the question:
delete from Product1 where Type = 'Regular';
--Checking the effect:
select * from Product1;
--29. Display the ASCII value of the fifth character from the column Product.
--Lets find the fifth character first:
SELECT SUBSTRING(Product, 5, 1) AS '5th_character_from_Product' FROM Product; --It gives blank where the 5th character is missing and the string is dhorter than 5 characters
--Lets use ASCII() funtion over the characters to get the result:
SELECT ASCII(SUBSTRING(Product, 5, 1)) AS ASCII_Value FROM Product;
--Note: The substring(' string / source table for string', 'start --> 5th character here so 5', 'Length --> 1 here since we only want the 5th character') parameters
--	  : The ASCII() function gives the ASCII code for the expression